# Opencode Rust TUI

## Overview

This project is a new Terminal User Interface (TUI) frontend for the `opencode` project. The frontend will be a standalone Rust application that communicates with the existing headless javascript server. It replaces the previous Go-based TUI.

The primary goals are to leverage Rust's performance and safety, establish a robust and maintainable architecture, and ensure compatibility with the project's existing backend services.

## Core Architecture

The application will strictly follow **The Elm Architecture**, a functional design pattern that separates state, logic, and rendering. This promotes predictability and simplifies state management.

The architecture consists of three main parts:

  - **Model**: A single Rust `struct` (e.g., `App`) that holds the entire state of the application. This includes user input, message history, file system state, agent status, etc. It is the single source of truth.

  - **Update**: A function or method (e.g., `App::update`) that contains all business logic. It takes the current `Model` and an `Event` as input and produces a new `Model`. It is the only part of the application that can modify the state.

  - **View**: A function (e.g., `ui`) that renders the user interface based on the current `Model`. It is stateless and declarative, receiving the `Model` and drawing to the terminal using `ratatui`. It does not contain any application logic.

An asynchronous main event loop will drive the application, polling for user input and network events, dispatching them to the **Update** function, and triggering a re-render by the **View** function.

## Technology Stack & Libraries

| Library / Tool        | Purpose                                                                                                                                  |
| --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| **Rust** | The core programming language for the project.                                                                                           |
| **`ratatui`** | The low-level TUI library for rendering widgets and managing layouts in the terminal.                                                    |
| **`crossterm`** | The terminal manipulation backend for `ratatui`. It handles raw mode, input events, and platform-specific terminal control.               |
| **`tokio`** | The asynchronous runtime for managing concurrent operations, primarily for handling user input and network I/O without blocking the UI. |
| **`reqwest`** | A high-level, ergonomic HTTP client for communicating with the Node.js backend API.                                                      |
| **`serde`** | A framework for serializing and deserializing Rust data structures to and from JSON for API communication.                               |
| **`anyhow`** | A library for flexible and easy-to-use error handling.                                                                                   |
| **`openapi.json`** | A static copy of the server's OpenAPI specification, used as a reference for creating type-safe API client functions and data models.  |

## Project Structure

The project will be organized into modules to maintain a clean separation of concerns.

```plaintext
opencoders/
├── Cargo.toml
├── openapi.json         # Static copy of the API spec
└── src/
    ├── main.rs               # Entry point, terminal setup, main event loop (utilizing logic from app/)
    ├── app/                  # Business logic and implementation of TUI architecture
    └── sdk/                  # Auto generated rust SDK for server API, packaged into APIClient struct, with request/response data models (structs)
```

As the application grows, the `Model`, `Update`, and `View` components may be extracted from `main.rs` into their own dedicated modules (e.g., `app.rs`, `ui.rs`, `event.rs`, and similar), structured within the `src/app/` folder.

## Key Implementation Details

### API Communication

  - All communication with the backend will be via HTTP requests made by the `ApiClient` defined in `src/sdk/`.
  - The `ApiClient` will use `reqwest` to perform asynchronous `POST`, `GET`, etc. operations.
  - All JSON request payloads and response bodies will be represented by strongly-typed Rust structs using `serde::Serialize` and `serde::Deserialize`.
  - The API contract is defined by the `openapi.json` file, which is generated by calling into the server's command line functionality.

### Terminal Handling (Alternate vs. Inline Mode)

  - The TUI must support running in two modes:
    1.  **Alternate Screen**: The default mode, where the TUI takes over the
        full terminal window, and can place dynamic UI features at all parts of
        the window.
    2.  **Inline Mode**: The TUI renders within the existing terminal history,
        and rewrites lines as necessary in the bottom most area of the terminal
        for dyanmic UI features..
  - This will be controlled via a command-line flag. The main function will conditionally execute `crossterm`'s `EnterAlternateScreen` and `LeaveAlternateScreen` commands based on this flag.
  - Terminal setup and restoration will be handled in a way that guarantees restoration even in the event of an application panic.
